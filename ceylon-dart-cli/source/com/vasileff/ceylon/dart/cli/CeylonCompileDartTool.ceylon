import ceylon.interop.java {
    javaClass,
    JavaIterable,
    javaString,
    CeylonList,
    CeylonIterable
}

import com.redhat.ceylon.common.config {
    DefaultToolOptions,
    CeylonConfig
}
import com.redhat.ceylon.common.tool {
    AnnotatedToolModel,
    ToolFactory,
    argument=argument__SETTER,
    option=option__SETTER,
    description=description__SETTER,
    optionArgument=optionArgument__SETTER,
    ToolError,
    parsedBy=parsedBy__SETTER,
    StandardArgumentParsers,
    EnumUtil
}
import com.redhat.ceylon.common.tools {
    CeylonTool,
    SourceArgumentsResolver,
    CeylonToolLoader,
    OutputRepoUsingTool,
    SourceDependencyResolver
}
import com.vasileff.ceylon.dart.compiler {
    dartBackend,
    compileDart,
    CompilationStatus,
    ReportableException,
    Warning
}

import java.io {
    JFile=File
}
import java.lang {
    JString=String,
    Class,
    Enum
}
import java.util {
    JList=List,
    EnumSet
}
import com.redhat.ceylon.cmr.api {
    ModuleQuery
}

shared
class CeylonCompileDartTool() extends OutputRepoUsingTool(null) {

    shared variable
    argument {
        argumentName = "moduleOrFile";
        multiplicity = "*";
    }
    JList<JString> moduleOrFile = DefaultToolOptions.getCompilerModules(dartBackend);

    shared variable option
    description("Wrap typeChecker.process() in TypeCache.doWithoutCaching \
                 (default is false)")
    Boolean doWithoutCaching = false;

    shared variable option
    description("Disable Ceylon version compatibility and language module availability \
                 checks (default is false)")
    Boolean disableCompatibilityCheck = false;

    shared variable option
    description("Generate a source artificat. Warning: this can cause problems if the
                 generated '.src' file conflicts with an existing '.src' artifact
                 generated by another backend, potentially in a different repository.")
    Boolean generateSourceArtifact = false;

    shared variable
    option { shortName = 'W'; }
    optionArgument { argumentName = "warnings"; }
    description {
        "Suppress the reporting of the given warnings. \
         If no `warnings` are given then suppresss the reporting of all warnings, \
         otherwise just suppresss those which are present. \
         Allowed flags include: \

         `filenameNonAscii`, `filenameCaselessCollision`,
         `deprecation`, `disjointEquals`,
         `disjointContainment`, `compilerAnnotation`,
         `doclink`, `expressionTypeNothing`,
         `unusedDeclaration`, `unusedImport`,
         `ceylonNamespace`, `javaNamespace`,
         `suppressedAlready`, `suppressesNothing`,
         `unknownWarning`, `ambiguousAnnotation`,
         `similarModule`, `importsOtherJdk`,
         `javaAnnotationElement`, `syntaxDeprecation`,
         `smallIgnored`, `literalNotSmall`,
         `redundantNarrowing`, `redundantIteration`,
         `missingImportPrefix`, `uncheckedTypeArguments`,
         `expressionTypeCallable`, `uncheckedType`,
         `unsupported`";
    }
    EnumSet<Warning> suppressWarning = (() {
        // compiler.suppresswarning option
        value result = EnumUtil.enumsFromStrings(javaClass<Warning>(),
                DefaultToolOptions.compilerSuppressWarnings)
                else EnumSet.noneOf(javaClass<Warning>());
        // compiler.dartsuppresswarning option
        result.addAll(enumsFromStrings(javaClass<Warning>(),
                getCompilerDartSuppressWarnings()));
        return result;
    })();

    shared actual variable
    option { shortName = 'd'; }
    optionArgument { argumentName = "flags"; }
    description {
        "Produce verbose output. \
         If no `flags` are given then be verbose about everything, \
         otherwise just be verbose about the flags which are present. \
         Allowed flags include: `all`, `loader`, `ast`, `rhAst`, \
         `code`, `profile`, `files`.";
    }
    String? verbose = null;

    shared variable option
    description {
        "Suppress output of successfull actions. \
         Errors and warnings will still be logged.";
    }
    Boolean quiet = false;

    optionArgument { longName="source"; argumentName="dirs"; }
    parsedBy { `class StandardArgumentParsers.PathArgumentParser`; }
    description {
        "An alias for `--src` (default: `./source`)";
    }
    shared variable
    JList<JFile>? source = null;

    optionArgument { shortName='s'; longName="src"; argumentName="dirs"; }
    parsedBy { `class StandardArgumentParsers.PathArgumentParser`; }
    description {
        "Path to source files. \
         Can be specified multiple times; you can also specify several \
         paths separated by your operating system's `PATH` separator. \
         (default: `./source`)";
    }
    shared variable
    JList<JFile>? src = null;

    shared variable option
    optionArgument {
        argumentName = "flags";
    }
    description {
        "Determines if and how compilation of dependencies should be handled. \
         Allowed flags include: `never`, `once`, `force`, `check`.";
    }
    String? includeDependencies = null;

    shared variable optionArgument
    description("Repeat compilation the specified number of times (useful for
                 performance testing).")
    JString? repeat = null;

    shared variable option
    description {
        "Include 'count nodes' visitors to determine baseline performance.";
    }
    Boolean baselinePerfTest = false;

    function verboseOption(String key)
        =>  if (exists v = verbose)
            then v.empty || v.contains("all") || v.contains(key)
            else false;

    Boolean verboseProfile => verboseOption("profile");
    Boolean verboseAst => verboseOption("ast");
    Boolean verboseRhAst => verboseOption("rhAst");
    Boolean verboseCode => verboseOption("code");
    Boolean verboseFiles => verboseOption("files");

    shared actual
    void initialize(CeylonTool? ceylonTool) {}

    suppressWarnings("expressionTypeNothing")
    shared actual
    void run() {
        try {
            value result = doRun();
            switch (result)
            case (CompilationStatus.success) { }
            case (CompilationStatus.errorTypeChecker
                    | CompilationStatus.errorDartBackend) {
                process.exit(1);
            }
        }
        catch (ReportableException e) {
            throw object extends ToolError(e.message, e.cause) {};
        }
    }

    CompilationStatus doRun() {
        if (!disableCompatibilityCheck) {
            checkCeylonVersion();
            verifyLanguageModuleAvailability(repositoryManager);
        }

        // TODO figure out why typechecking fails when sources for a single module
        //      are split among multiple source directories, sometimes, based on the
        //      order of the directories.
        value sourceDirectories
            =   applyCwd(src else source else DefaultToolOptions.compilerSourceDirs);

        value resources
            =   DefaultToolOptions.compilerResourceDirs;

        value resolver
            =   SourceArgumentsResolver(
                    sourceDirectories, resources, ".ceylon", ".dart");

        resolver.cwd(cwd).expandAndParse(moduleOrFile, dartBackend);

        if (exists id = includeDependencies, id != compileNever) {
            // Determine any dependencies that might need compiling as well
            value sdr = SourceDependencyResolver(sourceDirectories, dartBackend.asSet());
            if (sdr.cwd(cwd).traverseDependencies(resolver.sourceFiles)) {
                for (mvd in sdr.additionalModules) {
                    if (id == compileForce
                            || (id in [compileCheck, ""] && shouldRecompile(
                                        offlineRepositoryManager,
                                        mvd.\imodule, mvd.version,
                                        ModuleQuery.Type.dart, true))
                            || (id == compileOnce && shouldRecompile(
                                        offlineRepositoryManager,
                                        mvd.\imodule, mvd.version,
                                        ModuleQuery.Type.dart, false))) {
                        moduleOrFile.add(javaString(mvd.\imodule));
                        resolver.expandAndParse(moduleOrFile, dartBackend);
                    }
                }
            }
        }

        if (resolver.sourceFiles.empty && resolver.sourceModules.empty) {
            throw ReportableException("No modules or source files to compile.");
        }

        function doCompileDart()
            =>  compileDart {
                    sourceDirectories = CeylonList(sourceDirectories);
                    sourceFiles = CeylonList(resolver.sourceFiles);
                    moduleFilters = CeylonIterable(resolver.sourceModules)
                            .collect(Object.string);
                    repositoryManager = repositoryManager;
                    outputRepositoryManager = outputRepositoryManager;
                    suppressWarning = CeylonIterable(suppressWarning);
                    generateSourceArtifact = generateSourceArtifact;
                    doWithoutCaching = doWithoutCaching;
                    verboseAst = verboseAst;
                    verboseRhAst = verboseRhAst;
                    verboseCode = verboseCode;
                    verboseProfile = verboseProfile;
                    verboseFiles = verboseFiles;
                    quiet = quiet;
                    baselinePerfTest = baselinePerfTest;
                }[1];

        value repeatIterations
            =   if (exists r = repeat,
                    is Integer i = Integer.parse(r.string))
                then i
                else 0;

        for (_ in 0:repeatIterations) {
            doCompileDart();
        }
        return doCompileDart();
    }
}

"Run the CeylonCompileDartTool, using arguments from [[process.arguments]]."
shared
void runCompileDartTool() {
    value args = JavaIterable(process.arguments.map(javaString));
    value tool = CeylonCompileDartTool();
    value toolLoader = CeylonToolLoader();
    value toolFactory = ToolFactory();
    value toolModel = AnnotatedToolModel<CeylonCompileDartTool>("compile-dart");
    toolModel.toolLoader = toolLoader;
    toolModel.toolClass = javaClass<CeylonCompileDartTool>();
    toolFactory.bindArguments(toolModel, tool, CeylonTool(), args);
    tool.run();
}

[String*] getCompilerDartSuppressWarnings()
    =>  if (exists warnings
            =   CeylonConfig.get().getOptionValues("compiler.dartsuppresswarning"))
        then warnings.iterable.coalesced.map(Object.string).sequence()
        else [];

EnumSet<EnumType> enumsFromStrings<EnumType>(
        Class<EnumType> enumClass, [String*] elements)
        given EnumType satisfies Enum<EnumType> {
    value result = EnumSet<EnumType>.noneOf(enumClass);
    value allValues = EnumSet.allOf(enumClass);
    for (element in elements.map(String.trimmed)
                            .map((String s) => s.replace("-", "_"))) {
        for (e in allValues) {
            if (e.name().equalsIgnoringCase(element)) {
                result.add(e);
            }
        }
    }
    return result;
}
