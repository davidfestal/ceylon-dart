import ceylon.ast.core {
    ValueDeclaration,
    ValueDefinition,
    FunctionDeclaration,
    TypeAliasDefinition,
    WideningTransformer,
    Node,
    FunctionDefinition,
    InterfaceDefinition,
    FunctionShortcutDefinition,
    ValueGetterDefinition,
    LazySpecifier,
    AnyValue,
    AnyFunction
}

import com.redhat.ceylon.model.typechecker.model {
    ClassOrInterfaceModel=ClassOrInterface,
    InterfaceModel=Interface,
    TypedDeclarationModel=TypedDeclaration
}
import com.vasileff.ceylon.dart.ast {
    DartSimpleIdentifier,
    DartMethodDeclaration,
    DartClassMember,
    DartFormalParameterList,
    DartSimpleFormalParameter,
    dartFormalParameterListEmpty
}
import com.vasileff.ceylon.dart.nodeinfo {
    AnyFunctionInfo,
    ValueDefinitionInfo,
    ValueGetterDefinitionInfo,
    AnyValueInfo
}

shared
class ClassMemberTransformer(CompilationContext ctx)
        extends BaseGenerator(ctx)
        satisfies WideningTransformer<[DartClassMember*]> {

    shared actual
    [DartClassMember*] transformValueDeclaration(ValueDeclaration that) {
        // skip native declarations entirely, for now
        if (!isForDartBackend(that)) {
            return [];
        }
        return [generateMethodOrGetterDeclaration(that)];
    }

    shared actual
    [DartClassMember*] transformValueDefinition(ValueDefinition that) {
        // skip native declarations entirely, for now
        if (!isForDartBackend(that)) {
            return [];
        }

        value info = ValueDefinitionInfo(that);

        "The container of a class or interface member is surely a ClassOrInterface"
        assert (is ClassOrInterfaceModel container = info.declarationModel.container);

        if (!container is InterfaceModel) {
            // TODO support classes; assuming interface code below
            throw CompilerBug(that, "classes not yet supported");
        }

        value specifier = that.definition;

        "Interfaces don't have fields"
        assert(is LazySpecifier specifier);

        return [generateMethodOrGetterDeclaration(that),
                generateStaticGetterMethod(that)];
    }

    shared actual
    [DartClassMember*] transformValueGetterDefinition(ValueGetterDefinition that) {
        // skip native declarations entirely, for now
        if (!isForDartBackend(that)) {
            return [];
        }
        return [generateMethodOrGetterDeclaration(that),
                generateStaticGetterMethod(that)];
    }

    shared actual
    []|[DartMethodDeclaration] transformFunctionDeclaration(FunctionDeclaration that) {
        // skip native declarations entirely, for now
        if (!isForDartBackend(that)) {
            return [];
        }
        return [generateMethodOrGetterDeclaration(that)];
    }

    shared actual
    [DartMethodDeclaration*] transformFunctionShortcutDefinition
            (FunctionShortcutDefinition that) {
        // skip native declarations entirely, for now
        if (!isForDartBackend(that)) {
            return [];
        }

        return [generateMethodOrGetterDeclaration(that),
                generateInterfaceFunctionDefinition(that)];
    }

    shared actual
    [DartMethodDeclaration*] transformFunctionDefinition(FunctionDefinition that) {
        // skip native declarations entirely, for now
        if (!isForDartBackend(that)) {
            return [];
        }

        return [generateMethodOrGetterDeclaration(that),
                generateInterfaceFunctionDefinition(that)];
    }

    "Generates a method or getter declaration (not to be confused with *definition*).
     Note: Setter declarations are *not* generated by this method, and may be needed
     for mutable values or those with setters."
    DartMethodDeclaration generateMethodOrGetterDeclaration
            (AnyFunction | AnyValue that) {

        value declarationModel =
            switch (that)
            case (is AnyValue)
                AnyValueInfo(that).declarationModel
            case (is AnyFunction)
                AnyFunctionInfo(that).declarationModel;

        "The container of a class or interface member is surely a ClassOrInterface"
        assert (is ClassOrInterfaceModel container =
                (declarationModel of TypedDeclarationModel).container);

        value [identifier, isFunction]
            =   dartTypes.dartIdentifierForFunctionOrValueDeclaration {
                    that;
                    declarationModel;
                };

        return
        DartMethodDeclaration {
            false;
            null;
            if (is AnyFunction that)
                then generateFunctionReturnType(AnyFunctionInfo(that))
                else dartTypes.dartReturnTypeNameForDeclaration {
                        that;
                        declarationModel;
                    };
            !isFunction then "get";
            identifier;
            parameters =
                if (isFunction, is AnyFunction that) then
                    generateFormalParameterList(that, that.parameterLists.first)
                else if (isFunction) then
                    dartFormalParameterListEmpty
                else
                    null;
            body = null;
        };
    }

    DartMethodDeclaration generateStaticGetterMethod
            (ValueDefinition | ValueGetterDefinition that) {

        value declarationModel =
            switch (that)
            case (is ValueDefinition)
                ValueDefinitionInfo(that).declarationModel
            case (is ValueGetterDefinition)
                ValueGetterDefinitionInfo(that).declarationModel;

        "The container of a class or interface member is surely a ClassOrInterface"
        assert (is ClassOrInterfaceModel container = declarationModel.container);

        if (!container is InterfaceModel) {
            // TODO support classes; assuming interface code below
            throw CompilerBug(that, "classes not yet supported");
        }

        // Member functions of interfaces need a $this parameter.
        DartSimpleFormalParameter? thisParameter;
        if (is InterfaceModel container) {
            thisParameter = DartSimpleFormalParameter {
                true; false;
                dartTypes.dartTypeName {
                    that;
                    container.type;
                    false; false;
                };
                DartSimpleIdentifier("$this");
            };
        }
        else {
            thisParameter = null;
        }

        // Generate a DartFunctionExpression, then scrap it for parts
        value functionExpression =
                generateForValueDefinitionGetter(that).functionExpression;

        DartFormalParameterList standardParameters = dartFormalParameterListEmpty;

        // a static method definition for the actual implementation
        return
        DartMethodDeclaration {
            false;
            "static";
            dartTypes.dartReturnTypeNameForDeclaration {
                that;
                declarationModel;
            };
            null;
            DartSimpleIdentifier {
                dartTypes.getStaticInterfaceMethodName {
                    declarationModel;
                };
            };
            DartFormalParameterList {
                true; false;
                [
                    thisParameter,
                    *standardParameters.parameters
                ].coalesced.sequence();
            };
            functionExpression.body;
        };
    }

    // TODO consolidate w/getters
    DartMethodDeclaration generateInterfaceFunctionDefinition
            (FunctionDefinition | FunctionShortcutDefinition that) {

        value info = AnyFunctionInfo(that);

        "The container of a class or interface member is surely a ClassOrInterface"
        assert (is ClassOrInterfaceModel container = info.declarationModel.container);

        if (!container is InterfaceModel) {
            // TODO support classes; assuming interface code below
            throw CompilerBug(that, "classes not yet supported");
        }

        // Member functions of interfaces need a $this parameter.
        DartSimpleFormalParameter? thisParameter;
        if (is InterfaceModel container) {
            thisParameter = DartSimpleFormalParameter {
                true; false;
                dartTypes.dartTypeName {
                    that;
                    container.type;
                    false; false;
                };
                DartSimpleIdentifier("$this");
            };
        }
        else {
            thisParameter = null;
        }

        // Generate a DartFunctionExpression, then scrap it for parts
        value functionExpression = generateFunctionExpression(that);
        assert (exists standardParameters = functionExpression.parameters);

        // TODO defaulted parameters! (see also transformFunctionDefinition)

        // a static method definition for the actual implementation
        return
        DartMethodDeclaration {
            false;
            "static";
            generateFunctionReturnType(info);
            null;
            DartSimpleIdentifier {
                dartTypes.getStaticInterfaceMethodName {
                    info.declarationModel;
                };
            };
            DartFormalParameterList {
                true; false;
                [
                    thisParameter,
                    *standardParameters.parameters
                ].coalesced.sequence();
            };
            functionExpression.body;
        };
    }

    shared actual
    [] transformTypeAliasDefinition(TypeAliasDefinition that)
        =>  [];

    shared actual
    [] transformInterfaceDefinition(InterfaceDefinition that) {
        that.visit(topLevelVisitor);
        return [];
    }

    shared actual default
    [] transformNode(Node that) {
        throw CompilerBug(that,
            "Unhandled node: '``className(that)``'");
    }
}
